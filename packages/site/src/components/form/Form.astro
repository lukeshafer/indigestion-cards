---
import type { HTMLAttributes } from 'astro/types'
type Props = HTMLAttributes<'form'> & {
	loadingText?: string
}
export type FormProps = Props
const { class: className = '', action, method, loadingText, ...attrs } = Astro.props

export const inputClasses = {
	input: '',
	inputWrapper: '',
	readOnly: '',
	select: '',
	fieldset: '',
	button: '',
	submit: '',
}
---

<my-form class={className}>
	<div class="relative">
		<form
			method={method ?? 'post'}
			action={action}
			{...attrs}
			class="flex flex-col items-start gap-6 text-xl w-full">
			<slot />
		</form>
		<div
			aria-hidden="true"
			data-loading-spinner
			style={{
				display: 'none',
			}}>
			<img src="/lilindPB.gif" />
			<span class="loading-text text-left">{loadingText || 'Saving'}</span>
		</div>
	</div>
</my-form>

<style is:global>
	@keyframes loading-elipses {
		0% {
			content: '';
		}
		25% {
			content: '.';
		}
		50% {
			content: '..';
		}
		75% {
			content: '...';
		}
		100% {
			content: '';
		}
	}

	my-form .loading-text::after {
		position: absolute;
		animation: loading-elipses 3s infinite;
		content: '';
	}

	my-form [data-loading-spinner] {
		position: absolute;
		flex-direction: column;
		inset: 0;
		height: 100%;
		width: 100%;
		justify-content: center;
		align-items: center;
	}

	my-form input,
	my-form textarea,
	my-form select,
	.my-form-input,
	.my-form-textarea,
	.my-form-select {
		display: block;
		width: 100%;
		padding: 0.5rem;
		background-color: #fff;
		color: black;
	}

	my-form input[readonly],
	.my-form-input[readonly] {
		background-color: #eee;
	}

	my-form div button.edit-button {
		position: absolute;
		right: 0;
		top: 0;
		bottom: 0;
		background: none;
		border: none;
		opacity: 0.5;
		color: black;
	}

	my-form div button.edit-button:hover {
		background: none;
		opacity: 1;
	}

	my-form textarea,
	.my-form-textarea {
		height: 100px;
	}

	my-form
		:where(
			input[type='text'],
			input[type='email'],
			input[type='password'],
			input[type='number'],
			select,
			textarea,
			input:not(input[type])
		),
	.my-form-input,
	.my-form-textarea,
	.my-form-select {
		outline: 1px solid #ccc;
	}

	my-form label {
		display: block;
		font-weight: 600;
		font-family: var(--font-heading);
	}

	my-form label.required::after {
		content: ' *';
		color: red;
	}

	my-form input[type='checkbox'] {
		display: inline-block;
		width: auto;
	}

	my-form input[type='checkbox'] + label {
		display: inline-block;
		font-weight: 400;
	}

	my-form fieldset label {
		display: inline-block;
		font-size: 0.9em;
		font-weight: 500;
	}

	my-form input[type='file'] {
		display: flex;
		flex-direction: column;
		font-family: var(--font-heading);
		padding-inline: 0;
	}

	my-form input[type='file'] + img.preview {
		max-width: 20rem;
		object-fit: contain;
		margin: 0;
	}

	my-form input::file-selector-button {
		@apply font-medium font-heading p-2 text-shadow;
		margin-bottom: 0.5rem;
		display: block;
		border: 1px solid #ccc;
		background: var(--color-tertiary);
		cursor: pointer;
		color: white;
		transition: background 0.2s ease;
		content: 'Choose a file';
	}

	my-form input::file-selector-button:hover {
		background: var(--color-secondary);
	}

	my-form .input-group {
		display: flex;
		flex-flow: column;
		align-items: flex-start;
		width: 100%;
	}

	my-form :is(button, input[type='button'], input[type='submit']) {
		@apply text-shadow shine;
		font-family: var(--font-heading);
		padding: 0.5rem;
		display: block;
		border: 1px solid #ccc;
		background: var(--color-tertiary);
		cursor: pointer;
		color: white;
		transition: background 0.2s ease;
	}

	my-form
		:is(
			button:hover,
			input[type='button']:hover,
			input[type='submit']:hover,
			button[type='submit']:hover
		) {
		background-color: var(--color-secondary);
	}

	my-form :is(button[type='submit'], input[type='submit']) {
		font-weight: 700;
		text-transform: uppercase;
		background-color: var(--color-tertiary);
	}

	my-form fieldset {
		/*fieldset: 'border border-gray-300 p-4 w-full grid gap-8',*/
		border: 1px solid #ccc;
		padding: 1rem;
		width: 100%;
		display: grid;
		gap: 1rem;
	}

	my-form legend {
		font-weight: 600;
		font-size: 1.2rem;
	}
</style>

<script>
	class MyForm extends HTMLElement {
		constructor() {
			super()
		}

		connectedCallback() {
			const url = new URL(window.location.href)
			const params = new URLSearchParams(url.search)
			params.forEach((value, key) => {
				// if key is 'form-xxx', we want to query for 'input[name="xxx"]'
				const inputName = key === 'form' ? 'form' : key.replace(/^form-/, '')
				if (!inputName) return
				const input = this.querySelector(`input[name="${inputName}"]`) as HTMLInputElement | null
				if (!input) return
				input.value = value
			})

			const form = this.querySelector('form') as HTMLFormElement
			const loadingSpinner = this.querySelector('[data-loading-spinner]') as HTMLDivElement
			form.addEventListener('submit', (e) => {
				if (e.defaultPrevented) return
				form.style.opacity = '0.5'
				loadingSpinner.style.display = 'flex'
			})

			const idInputs = this.querySelectorAll('[data-id-from]')
			idInputs.forEach((input) => {
				if (!(input instanceof HTMLInputElement)) return

				const bindId = input.getAttribute('data-id-from')
				if (!bindId) return

				const idInput = this.querySelector(`[name="${bindId}"]`) as HTMLInputElement | null
				if (!idInput) return

				idInput.addEventListener('change', () => {
					input.value = idInput.value.toLowerCase().replace(/[^a-z0-9]/g, '-')
				})
			})

			const fileInputs = this.querySelectorAll('input[type="file"]')
			fileInputs.forEach((input) => {
				if (!(input instanceof HTMLInputElement)) return
				const preview = document.createElement('img')
				preview.classList.add('preview')
				input.after(preview)

				const addPreview = () => {
					const file = input.files?.[0]
					if (!file || !file.type.startsWith('image/')) {
						preview.src = ''
						return
					}
					preview.src = URL.createObjectURL(file)
				}

				addPreview()
				input.addEventListener('change', addPreview)
			})

			const readonlyWithEditButton = this.querySelectorAll('[data-edit-button]')

			readonlyWithEditButton.forEach((input) => {
				if (!(input instanceof HTMLInputElement)) return

				const wrapper = document.createElement('div')
				wrapper.style.position = 'relative'
				wrapper.style.width = '100%'
				input.after(wrapper)
				wrapper.append(input)

				const editButton = document.createElement('button')
				editButton.textContent = 'Edit'
				editButton.classList.add('edit-button')

				editButton.addEventListener('click', (e) => {
					e.preventDefault()
					if (!input.readOnly) return
					input.readOnly = false
					input.focus()
					editButton.style.display = 'none'
				})
				wrapper.append(editButton)
			})

			this.querySelectorAll('.input-group').forEach((group) => {
				const label = group.querySelector<HTMLLabelElement>('label')
				const inputs = group.querySelectorAll<HTMLInputElement | HTMLSelectElement>(
					'input, textarea, select'
				)
				inputs.forEach((input) => {
					if (input.required) {
						label?.classList.add('required')
					}
				})
			})
		}
	}

	customElements.define('my-form', MyForm)
</script>
