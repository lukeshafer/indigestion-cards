---
import type { HTMLAttributes } from 'astro/types';
type Props = HTMLAttributes<'form'> & {
	loadingText?: string;
};
export type FormProps = Props;
const { class: className = '', action, method, loadingText, ...attrs } = Astro.props;

export const inputClasses = {
	input: '',
	inputWrapper: '',
	readOnly: '',
	select: '',
	fieldset: '',
	button: '',
	submit: '',
};
---

<my-form class={className}>
	<div class="relative">
		<form
			method={method ?? 'post'}
			action={action}
			{...attrs}
			class="flex flex-col items-start gap-6 w-full">
			<slot />
		</form>
		<div
			aria-hidden="true"
			data-loading-spinner
			style={{
				display: 'none',
			}}>
			<img src="/lilindPB.gif" />
			<span class="loading-text text-left">{loadingText || 'Saving'}</span>
		</div>
	</div>
</my-form>

<style is:global>
	my-form .loading-text::after {
		position: absolute;
		animation: loading-elipses 3s infinite;
		content: '';
	}

	my-form [data-loading-spinner] {
		position: absolute;
		flex-direction: column;
		inset: 0;
		height: 100%;
		width: 100%;
		justify-content: center;
		align-items: center;
	}
</style>

<script>
	class MyForm extends HTMLElement {
		constructor() {
			super();
		}

		connectedCallback() {
			const url = new URL(window.location.href);
			const params = new URLSearchParams(url.search);
			params.forEach((value, key) => {
				// if key is 'form-xxx', we want to query for 'input[name="xxx"]'
				const inputName = key === 'form' ? 'form' : key.replace(/^form-/, '');
				if (!inputName) return;
				const input = this.querySelector(
					`input[name="${inputName}"]`
				) as HTMLInputElement | null;
				if (!input) return;
				input.value = value;
			});

			const form = this.querySelector('form') as HTMLFormElement;
			const loadingSpinner = this.querySelector('[data-loading-spinner]') as HTMLDivElement;
			form.addEventListener('submit', (e) => {
				if (e.defaultPrevented) return;
				form.style.opacity = '0.5';
				loadingSpinner.style.display = 'flex';
			});

			const idInputs = this.querySelectorAll('[data-id-from]');
			idInputs.forEach((input) => {
				if (!(input instanceof HTMLInputElement)) return;

				const bindId = input.getAttribute('data-id-from');
				if (!bindId) return;

				const idInput = this.querySelector(`[name="${bindId}"]`) as HTMLInputElement | null;
				if (!idInput) return;

				idInput.addEventListener('change', () => {
					input.value = idInput.value.toLowerCase().replace(/[^a-z0-9]/g, '-');
				});
			});

			const fileInputs = this.querySelectorAll('input[type="file"]');
			fileInputs.forEach((input) => {
				if (!(input instanceof HTMLInputElement)) return;
				const preview = document.createElement('img');
				preview.classList.add('preview');
				input.after(preview);

				const addPreview = () => {
					const file = input.files?.[0];
					if (!file || !file.type.startsWith('image/')) {
						preview.src = '';
						return;
					}
					preview.src = URL.createObjectURL(file);
				};

				addPreview();
				input.addEventListener('change', addPreview);
			});

			const readonlyWithEditButton = this.querySelectorAll('[data-edit-button]');

			readonlyWithEditButton.forEach((input) => {
				if (!(input instanceof HTMLInputElement)) return;

				const wrapper = document.createElement('div');
				wrapper.style.position = 'relative';
				wrapper.style.width = '100%';
				input.after(wrapper);
				wrapper.append(input);

				const editButton = document.createElement('button');
				editButton.type = 'button';
				editButton.textContent = 'Edit';
				editButton.classList.add('edit-readonly');

				editButton.addEventListener('click', (e) => {
					e.preventDefault();
					if (!input.readOnly) return;
					input.readOnly = false;
					input.focus();
					editButton.style.display = 'none';
				});
				wrapper.append(editButton);
			});

			this.querySelectorAll('.input-group').forEach((group) => {
				const label = group.querySelector<HTMLLabelElement>('label');
				const inputs = group.querySelectorAll<HTMLInputElement | HTMLSelectElement>(
					'input, textarea, select'
				);
				inputs.forEach((input) => {
					if (input.required) {
						label?.classList.add('required');
					}
				});
			});
		}
	}

	customElements.define('my-form', MyForm);
</script>
