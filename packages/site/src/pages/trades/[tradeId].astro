---
import { DeleteButton, SubmitButton } from '@/components/form/Form';
import { Heading } from '@/components/text';
import OfferWindow from '@/components/trades/OfferWindow';
import TradeMessageHistory from '@/components/trades/TradeMessageHistory';
import { routeNames, routes } from '@/constants';
import Page, { type Props as PageProps } from '@/layouts/Page.astro';
import { InputValidationError } from '@lil-indigestion-cards/core/lib/errors';
import { validateSearchParams } from '@lil-indigestion-cards/core/lib/api';
import { removeTradeNotification } from '@lil-indigestion-cards/core/lib/user';
import {
	getTrade,
	updateTradeStatus,
	addMessageToTrade,
} from '@lil-indigestion-cards/core/lib/trades';
import { Show } from 'solid-js';

const alerts: PageProps['alerts'] = [];

const username = Astro.locals.user?.properties.username;
const userId = Astro.locals.user?.properties.userId;

const tradeId = Astro.params.tradeId;
if (!tradeId) {
	return Astro.redirect('/trades?alert=Invalid trade ID&type=error');
}

if (Astro.request.method === 'POST') {
	if (!username || !userId) {
		return new Response('You must be logged in to update a trade.', {
			status: 401,
		});
	}
	const body = new URLSearchParams(await Astro.request.text());
	const result = validateSearchParams(body, {
		status: 'string?',
		message: 'string?',
	});

	if (!result.success) {
		alerts.push({ type: 'error', message: 'No data provided in request.' });
	} else if (Object.values(result.value).every((v) => v === undefined)) {
		alerts.push({ type: 'error', message: 'No update status provided.' });
	} else {
		const { status, message } = result.value;

		if (status)
			try {
				await updateTradeStatus({
					tradeId,
					status,
					loggedInUserId: userId,
				});
			} catch (err) {
				if (err instanceof InputValidationError) {
					alerts.push({ type: 'error', message: err.message });
				} else {
					console.error(err);
					alerts.push({
						type: 'error',
						message: 'An error occurred while updating the trade.',
					});
				}
			}

		if (message) {
			await addMessageToTrade({
				loggedInUserId: userId,
				tradeId,
				message: {
					message,
					userId,
					type: 'message',
				},
			});
			// add message to the trade data
		}
	}
}

const trade = await getTrade(tradeId);
if (!trade) {
	return Astro.redirect('/trades?alert=Trade not found&type=error');
}

const isSender = trade.senderUsername === username;
const isReceiver = trade.receiverUsername === username;

if (userId && (isSender || isReceiver)) {
	console.log('removing trade notification');
	await removeTradeNotification({ userId, tradeId });
}

const tradeStatus = (() => {
	switch (trade.status) {
		case 'pending':
			if (isReceiver) return 'Awaiting your response';
			else return `Awaiting ${trade.receiverUsername}'s response`;
		case 'rejected':
			if (isReceiver) return 'Rejected by you';
			return `Rejected by ${trade.receiverUsername}`;
		case 'accepted':
			if (isReceiver) return 'Accepted, trade processing...';
			else if (isSender) return `${trade.receiverUsername} accepted your trade!`;
			else return `${trade.receiverUsername} accepted the trade`;
		case 'canceled':
			return `Canceled by ${isSender ? 'you' : trade.senderUsername}`;
		case 'completed':
			return 'Trade completed';
	}
})();
---

<Page
	title="Trades"
	pageType="public"
	breadcrumbs={userId
		? [{ label: routeNames.TRADES, href: routes.TRADES }, { label: 'Trade' }]
		: [{ label: routeNames.TRADES }, { label: 'Trade' }]}>
	<br />
	<div class="grid-wrapper grid gap-2">
		<style>
			.grid-wrapper {
				grid-template-columns: 1fr 1fr;
				@container main (max-width: 600px) {
					grid-template-columns: 1fr;
				}
			}
		</style>
		<div class="col-span-full text-center">
			<Heading classList={{ grid: true }}>
				<span>STATUS</span>
				<span
					class="text-xl"
					class:list={{
						'text-brand-dark dark:text-brand-main':
							trade.status === 'accepted' || trade.status === 'completed',
						'text-gray-500 dark:text-gray-400': trade.status === 'pending',
						'text-red-700 dark:text-red-500':
							trade.status === 'rejected' || trade.status === 'canceled',
					}}>{tradeStatus}</span
				>
			</Heading>
		</div>
		<div class="text-center">
			<h2 class="font-heading my-2 text-xl font-semibold text-gray-800 dark:text-gray-200">
				{isSender ? 'Your offer' : `${trade.senderUsername}'s offer`}
			</h2>
			<OfferWindow cards={trade.offeredCards} client:load />
		</div>
		<div class="text-center">
			<h2 class="font-heading my-2 text-xl font-semibold text-gray-800 dark:text-gray-200">
				{isReceiver ? 'Requested from you' : `Requested from ${trade.receiverUsername}`}
			</h2>
			<OfferWindow cards={trade.requestedCards} client:load />
		</div>
		<TradeMessageHistory {trade} loggedInUserId={userId} client:load />
		<Show when={trade.status === 'pending'}>
			<div class="col-span-full justify-self-center">
				{
					isSender ? (
						<form method="post">
							<input type="hidden" name="tradeId" value={trade.tradeId} />
							<input type="hidden" name="status" value="canceled" />
							<DeleteButton>Cancel offer</DeleteButton>
						</form>
					) : isReceiver ? (
						<div class="flex flex-wrap gap-2">
							<form method="post">
								<input type="hidden" name="tradeId" value={trade.tradeId} />
								<input type="hidden" name="status" value="accepted" />
								<SubmitButton
									confirm="Are you sure you want to accept this trade? Once accepted, the trade is final and cannot be reversed."
									client:idle>
									<div class="min-w-[8rem]">Accept offer</div>
								</SubmitButton>
							</form>
							<form method="post">
								<input type="hidden" name="tradeId" value={trade.tradeId} />
								<input type="hidden" name="status" value="rejected" />
								<DeleteButton
									confirm="Are you sure you want to reject this trade?"
									client:idle>
									<div class="min-w-[8rem]">Reject offer</div>
								</DeleteButton>
							</form>
						</div>
					) : null
				}
			</div>
		</Show>
	</div>

	<trade-fetcher trade-id={trade.tradeId} status={trade.status}></trade-fetcher>
	<script>
		import { get } from '@/lib/client/data';

		customElements.define(
			'trade-fetcher',
			class TradeFetcher extends HTMLElement {
				tradeId: string;
				status: string;
				constructor() {
					super();
					this.tradeId = this.getAttribute('trade-id') || '';
					this.status = this.getAttribute('status') || '';
				}

				connectedCallback() {
					const createTimeout = (time = 1000) => {
						setTimeout(() => {
							this.refreshIfTradeStatusUpdated();
							if (time < 128000) createTimeout(time * 2);
						}, time);
					};
					createTimeout();
				}

				async refreshIfTradeStatusUpdated() {
					const trade = await get('trades', [this.tradeId]);
					if (this.status !== trade.status) location.reload();
				}
			}
		);
	</script>
</Page>
